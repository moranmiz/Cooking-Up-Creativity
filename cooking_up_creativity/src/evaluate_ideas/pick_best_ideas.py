import json
from tqdm import tqdm
import os

from src.evaluate_ideas.compute_novelty import get_recipe_novelty_score
from src.evaluate_ideas.evaluate_taste import get_raw_ingredients, clean_ingredient, cause_taste_collisions

MIN_ELEMENT_RATIO = 0.3
HIGHEST_RANKED_K = 5


"""
This dictionary maps each of the 100 most common dishes in Recipe1M to its essential ingredients (e.g., for the 
dish "apple pie", the essential ingredient is "apple").
"""
with open("dish_to_essential_ingrs.json", 'r') as f:
    dish_to_essential_ingrs = json.load(f)

"""
The following dictionary caches cleaned ingredients for faster processing.
"""
cleaned_ingrs = {}


def get_elements_in_tree_dict(tree_dict: dict, ingrs_separately: bool = False) -> dict or tuple:
    """
    Returns a dictionary of elements in the given tree_dict. Each key in the dictionary is an element (ingredients or
    cooking action), and its value is the original label of the element in the tree.
    
    :param tree_dict: the tree dictionary
    :param ingrs_separately: a boolean flag indicating whether to return also the ingredient elements list separately
    :return: a dictionary of elements in tree_dict. If ingrs_separately is True, also return a list including only the
    ingredient elements in tree.
    """

    elements = {}
    ingr_elements = []
    act_elements = []

    for item in tree_dict:
        element = tree_dict[item]['label']
        element_type = tree_dict[item]['type']

        # remove number suffixes if there are:
        if element[-1].isdigit():
            element = element[:-1]

        if element_type == "ingredient":
            if element in cleaned_ingrs:  # use cleaned ingredient if available for faster processing
                element = cleaned_ingrs[element]
            else:
                cleaned_element = clean_ingredient(element)
                cleaned_ingrs[element] = cleaned_element
                element = cleaned_element
            if element:
                ingr_elements += [element]
        else:
            act_elements += [element]

        elements[element] = item

    ingr_elements = list(set(ingr_elements))

    if ingrs_separately:
        return elements, ingr_elements

    return elements


def dish_elements_ratio(tree_dict: dict) -> tuple:
    """
    Returns the ratio of elements in the new recipe from dish A and dish B.

    :param tree_dict: the tree dictionary of the generated recipe
    :return: a tuple (ratio_a, ratio_b) where ratio_a is the ratio of elements from dish A and ratio_b is the ratio of
             elements from dish B in the tree
    """

    elements = {"dish_A": 0, "dish_B": 0}

    for element in tree_dict:
        if element.endswith("_a"):
            elements["dish_A"] += 1
        elif element.endswith("_b"):
            elements["dish_B"] += 1

    ratio_a = elements["dish_A"] / (elements["dish_A"] + elements["dish_B"])
    ratio_b = 1.0 - ratio_a

    return ratio_a, ratio_b


def get_dish_pair_direction(recipe_name: str, dish_pair_str: str) -> str:
    """
    Returns the direction of transformation used for generating recipe_name.

    :param recipe_name: the name of the generated recipe
    :param dish_pair_str: the dish pair string used for generating the recipe (e.g., "apple_pie_to_chocolate_cake")
    :return: "a->b" if the recipe is generated by transforming dish A to dish B, "b->a" otherwise
    """

    dish1 = dish_pair_str.split("_to_")[0].split("_")[0]

    if recipe_name.startswith(dish1.replace(" ", "_")):
        return "a->b"

    return "b->a"


def contain_essentials(recipe_ingrs: list, dish_name: str) -> tuple:
    """
    Checks if the recipe contains an essential ingredient for the given dish.

    :param recipe_ingrs: list of ingredients in the recipe
    :param dish_name: the name of the dish
    :return: a tuple (contain_essentials, essentials_in_recipe) where contain_essentials is True if the recipe
             contains at least one essential ingredient for the dish, and essentials_in_recipe is a list of essential
             ingredients found in the recipe
    """

    dish_name = dish_name.replace("_", " ")
    essentials = dish_to_essential_ingrs[dish_name]

    contain_essentials = False
    essentials_in_recipe = []

    if not essentials:
        contain_essentials = True
    else:
        for essential in essentials:
            for ingr in recipe_ingrs:
                if essential in ingr:
                    contain_essentials = True
                    essentials_in_recipe += [ingr]

    return contain_essentials, essentials_in_recipe


def remove_bad_ingredients_from_tree(tree_dict: dict, bad_ingrs_labels: list) -> dict:
    """
    Removes bad ingredient elements from the given tree dictionary.

    :param tree_dict: the tree dictionary that represents the recipe idea
    :param bad_ingrs_labels: a list of bad ingredient labels to remove from the tree
    :return: an updated tree dictionary with the bad ingredients removed
    """

    updated_tree_dict = {}

    for node_name in tree_dict:

        children = tree_dict[node_name]['children']
        children = [c for c in children if c not in bad_ingrs_labels]

        if node_name not in bad_ingrs_labels:
            updated_tree_dict[node_name] = tree_dict[node_name].copy()
            updated_tree_dict[node_name]['children'] = children

    return updated_tree_dict


def create_simplified_dot_code_rec(tree_dict: dict, sub_tree_root: str, ingr_names: dict = {},
                                   action_num: int = 1) -> tuple:
    """
    Recursive function to create simplified dot code from tree_dict.

    :param tree_dict: the tree dictionary
    :param sub_tree_root: the current subtree root
    :param ingr_names: a dictionary of ingredient names
    :param action_num: the current action number
    :return: a tuple (text_till_now, text_till_now_ingr, text_till_now_actions, text_till_now_edges,
    ingr_names, action_num) where text_till_now is the text representation of the recipe so far,
    text_till_now_ingr is the DOT code for ingredient nodes, text_till_now_actions is the DOT code
    for action nodes, text_till_now_edges is the DOT code for edges, ingr_names is the updated
    ingredient names dictionary, and action_num is the updated action number
    """

    if not tree_dict[sub_tree_root]["children"]:
        if tree_dict[sub_tree_root]["type"] == "action":
            tree_dict[sub_tree_root]["new_node_name"] = "i" + str(action_num)
            action_num += 1
            action_label = tree_dict[sub_tree_root]["label"]
            action_label = ''.join([i for i in action_label if not i.isdigit()])
            return tree_dict[sub_tree_root]["label"].title() + ". ", "", "\t" + tree_dict[sub_tree_root]["new_node_name"] + "[label=\"" + action_label + "\"];\n", "", ingr_names, action_num
    else:
        ingr_children = []
        text_till_now = ""
        text_till_now_ingr = ""
        text_till_now_actions = ""
        text_till_now_edges = ""
        for child in tree_dict[sub_tree_root]["children"]:
            if tree_dict[child]["type"] == "action":
                text_to_add, text_ingr, text_actions, text_edges, ingr_names, action_num = create_simplified_dot_code_rec(tree_dict, child, ingr_names, action_num)
                text_till_now += text_to_add
                text_till_now_ingr += text_ingr
                text_till_now_actions += text_actions
                text_till_now_edges += text_edges
            else:
                new_ingr_node_name = child[:-2]
                new_ingr_node_name = ''.join([i for i in new_ingr_node_name if not i.isdigit()])

                if new_ingr_node_name not in ingr_names:
                    ingr_names[new_ingr_node_name] = [child]  # old node name
                    tree_dict[child]["new_node_name"] = new_ingr_node_name
                elif new_ingr_node_name in ingr_names:
                    ingr_names[new_ingr_node_name] += [child]
                    tree_dict[child]["new_node_name"] = new_ingr_node_name + str(len(ingr_names[new_ingr_node_name]))

                ingr_children += [child]

        tree_dict[sub_tree_root]["new_node_name"] = "i" + str(action_num)
        action_num += 1
        text_till_now += tree_dict[sub_tree_root]["label"].title()
        action_label = tree_dict[sub_tree_root]["label"]
        action_label = ''.join([i for i in action_label if not i.isdigit()])
        text_till_now_actions += "\t" + tree_dict[sub_tree_root]["new_node_name"] + "[label=\"" + action_label + "\"];\n"
        if ingr_children:
            text_till_now += " " + ', '.join([tree_dict[child]["label"] for child in ingr_children])
            for ingr in ingr_children:
                ingr_label = tree_dict[ingr]["label"]
                ingr_label = ''.join([i for i in ingr_label if not i.isdigit()])
                text_till_now_ingr += "\t" + tree_dict[ingr]["new_node_name"] + "[label=\"" + ingr_label + "\"];\n"

        for child in tree_dict[sub_tree_root]["children"]:
            text_till_now_edges += "\t" + tree_dict[child]["new_node_name"] + " -> " + tree_dict[sub_tree_root]["new_node_name"] + ";\n"
        text_till_now += ". "

        return text_till_now, text_till_now_ingr, text_till_now_actions, text_till_now_edges, ingr_names, action_num


def create_simplified_dot_code(tree_dict: dict) -> str:
    """
    Creates a simplified dot code for the given tree dictionary.
    To convert the tree dictionary into DOT, we traverse the tree using DFS. This ordering makes
    the resulting DOT graph easier for both humans and LLMs to interpret, since related operations
    appear close together and parents are defined before their children.

    :param tree_dict: the tree dictionary
    :return: the simplified dot code as a string
    """

    tree_root = [node for node in tree_dict if tree_dict[node]["parent"] == None][0]
    simplified_out = create_simplified_dot_code_rec(tree_dict, tree_root)
    text_till_now_ingr = simplified_out[1]
    text_till_now_actions = simplified_out[2]
    text_till_now_edges = simplified_out[3]

    simplified_dot = "digraph G {\n\n\trankdir=BT ratio=auto;\n\n" + text_till_now_ingr + "\n" + text_till_now_actions + "\n" + text_till_now_edges + "}"

    return simplified_dot


def is_valuable_idea(tree_dict: dict, dish_pair: str) -> tuple:
    """
    Check whether the recipe represented by tree_dict and tree_dot_code is valuable. If necessary, corrects
    the recipe by removing bad ingredients that collide in taste.

    :param tree_dict: the tree dictionary of the generated recipe
    :param tree_dot_code: the DOT representation of the generated recipe tree
    :param dish_pair: the dish pair string used for generating the recipe (e.g., "apple_pie_to_chocolate_cake")
    :return: a tuple (is_valuable, updated_tree_elements, updated_tree_code) where is_valuable is True if the recipe
    is valuable, False otherwise. If the recipe is valuable (possibly after correction), updated_tree_elements and
    updated_tree_code represent the corrected recipe. In case the recipe is not valuable, updated_tree_elements and
    updated_tree_code are None.
    """

    # we remove ideas that are too similar to seed recipes (to ensure that the combined tree
    # preserves cross-dish inspiration, we require that at least 30% of its elements come from each of the
    # original dishes):

    element_ratio_a, element_ratio_b = dish_elements_ratio(tree_dict)

    if element_ratio_a < MIN_ELEMENT_RATIO:
        return False, None, None

    all_elements, ingr_elements = get_elements_in_tree_dict(tree_dict, ingrs_separately=True)

    # we discard recipes that lack at least one essential ingredient from both original dishes
    # (not a necessary step -- we specifically wanted to ensure that essential ingredients from
    # both original dishes are present in the new recipe):

    essential_a, essentials_in_recipe_a = contain_essentials(ingr_elements, dish_pair.split("_to_")[0])
    essential_b, essentials_in_recipe_b = contain_essentials(ingr_elements, dish_pair.split("_to_")[1])

    if not essential_a or not essential_b:
        return False, None, None

    # compute novelty score:
    novelty_score, top_items_scores = get_recipe_novelty_score(all_elements, score_only=False)

    # remove ingredients that collide in taste (prefer to remove ingredients that are not essential for the
    # original dishes and that contribute less to the overall novelty score):
    top_items_order = [item[0] for item in top_items_scores]
    top_items_order = [item for item in top_items_order if item not in essentials_in_recipe_a and item not in essentials_in_recipe_b]
    top_items_order = essentials_in_recipe_a + essentials_in_recipe_b + top_items_order
    ingrs_to_remove = cause_taste_collisions(ingr_elements, top_items_order)

    updated_tree_elements = [e for e in all_elements if e not in ingrs_to_remove]

    # remove bad ingredient elements from the tree and create a simplified DOT representation of the tree:
    bad_ingrs_labels = [all_elements[ingr] for ingr in ingrs_to_remove]
    updated_tree_dict = remove_bad_ingredients_from_tree(tree_dict, bad_ingrs_labels)
    simplified_tree_code = create_simplified_dot_code(updated_tree_dict)

    return True, simplified_tree_code, updated_tree_elements


def ensure_value_rank_by_novelty(generated_ideas: dict) -> dict:
    """
    Ensures the value of generated ideas by removing bad ingredients that do not pair well in taste, and ranks
    the remaining ideas by their novelty score.

    :param generated_ideas: a dictionary of generated ideas
    :return: a dictionary of the valuable ideas among generated_ideas, ranked by their novelty score
    """

    valuable_ideas = {}

    for dish_pair in generated_ideas:

        for generated_id in tqdm(list(generated_ideas[dish_pair].keys())):

            tree_dict = generated_ideas_dict[dish_pair][generated_id]["tree_dict"]
            tree_dot_code = generated_ideas_dict[dish_pair][generated_id]["tree_dot_code"]

            # ensure value and remove ingredients that do not pair well in taste:
            is_valuable, simplified_dot_code, updated_elements = is_valuable_idea(tree_dict, dish_pair)

            if is_valuable:
                # compute the novelty score and
                novelty_score, element_scores = get_recipe_novelty_score(updated_elements, score_only=False)

                valuable_ideas[generated_id] = {}
                valuable_ideas[generated_id]["dish_pair"] = dish_pair
                valuable_ideas[generated_id]["recipe_a"] = generated_id.split("_to_")[0]
                valuable_ideas[generated_id]["recipe_b"] = '_'.join(generated_id.split("_to_")[1].split("_")[:-1])
                valuable_ideas[generated_id]["tree_dot_code"] = simplified_dot_code
                valuable_ideas[generated_id]["tree_novelty_score"] = novelty_score
                valuable_ideas[generated_id]["element_novelty_scores"] = element_scores

    # rank ideas by novelty:
    valuable_ranked_ideas = dict(sorted(valuable_ideas.items(), key=lambda item: item[1]["tree_novelty_score"], reverse=True))

    return valuable_ranked_ideas


def pick_top_k_ideas(ranked_ideas: dict, top_k: int = HIGHEST_RANKED_K, method: str = "different_origin") -> dict:
    """
    Picks the top-k ideas from the ranked ideas based on the specified method.

    :param ranked_ideas: a dictionary of ranked ideas
    :param top_k: a number indicating how many top ideas to pick at most
    :param method: the method to use for picking the top-k ideas. If None, simply picks the top-k ideas.
    :return: a dictionary of the picked top-k ideas
    """

    best_ideas = {}

    if not method:
        for idea in list(ranked_ideas.keys())[:top_k]:
            best_ideas[idea] = ranked_ideas[idea]

    elif method == "different_origin":
        origin_recipes = {}
        count = 0
        for idea in valuable_ranked_ideas:
            recipe_a = valuable_ranked_ideas[idea]["recipe_a"]
            recipe_b = valuable_ranked_ideas[idea]["recipe_b"]
            if recipe_a not in origin_recipes and recipe_b not in origin_recipes:
                best_ideas[idea] = valuable_ranked_ideas[idea]
                origin_recipes[recipe_a] = True
                origin_recipes[recipe_b] = True
                count += 1
                if count > top_k - 1:
                    break

    return best_ideas


if __name__ == '__main__':

    # generated_ideas_path = "apple_cake_to_chicken_breast.json"
    generated_ideas_path = "generated_recipes_tiny.json"

    with open(generated_ideas_path, 'r') as f:
        generated_ideas_dict = json.load(f)

    print(len(generated_ideas_dict))

    valuable_ranked_ideas = ensure_value_rank_by_novelty(generated_ideas_dict)

    best_ideas = pick_top_k_ideas(valuable_ranked_ideas, top_k=3, method="different_origin")

    with open(generated_ideas_path.replace(".json", "_best_ideas.json"), 'w') as f:
        json.dump(best_ideas, f, indent=4)